package rel

import (
	"time"

	"github.com/jessevdk/go-assets"
)

var _Assets46cddf908f5020eaa9e87763aca46435532701b4 = "{{$driver := .Driver -}}\n{{$embed := .Embed -}}\npackage {{.Package}}\n\nimport (\n\t\"database/sql\"\n\t{{- if eq $driver \"postgres\"}}\n\t\"fmt\"\n\t\"regexp\"\n\t{{- end}}\n\t\"strings\"\n\t\"time\"\n)\n\n{{- range .Tables}}\n{{$name := .Name}}\nconst (\n\t{{- range .Columns}}\n\t{{$name | Camel}}{{.Name | Camel}} = FieldName(`{{.Name | camel}}`)\n\t{{- end}}\n)\n\n// {{.Name | singular | Camel}} represents a record in {{.Name}} table.\ntype {{.Name | singular | Camel}} struct {\n{{- if $embed}}\n\t{{- range $embed}}\n\t{{.}}\n\t{{- end}}\n\n\t{{- end}}\n\t{{- range .Columns}}\n\t{{.Name | Camel}} {{.Type}} `json:\"{{.Name | camel}}\"`\n\t{{- end}}\n\tErrors map[FieldName]string `json:\"errors,omitempty\"`\n}\n\nfunc (m *{{.Name | singular | Camel}}) Create(db DB) error {\n\tcs := make([]string, 0, {{.Columns | len}})\n\tps := make([]string, 0, {{.Columns | len}})\n\tvs := make([]interface{}, 0, {{.Columns | len}})\n\tcs = append(cs{{range .Columns}}{{if not .Default}}, `{{.Name}}`{{end}}{{end}})\n\tps = append(ps{{range .Columns}}{{if not .Default}}, \"?\"{{end}}{{end}})\n\tvs = append(vs{{range .Columns}}{{if not .Default}}, m.{{.Name | Camel}}{{end}}{{end}})\n\t{{- range .Columns}}\n\t{{- if .Default}}\n\tif m.{{.Name | Camel}} != {{.Type | zero}} {\n\t\tcs = append(cs, `{{.Name}}`)\n\t\tps = append(ps, \"?\")\n\t\tvs = append(vs, m.{{.Name | Camel}})\n\t}\n\t{{- end}}\n\t{{- end}}\n\t{{- if eq $driver \"postgres\"}}\n    row := db.QueryRow(`INSERT INTO {{.Name}}(` + strings.Join(cs, \", \") + `) VALUES (` + strings.Join(ps, \", \") + `) RETURNING {{range $index, $column := .Columns}}{{if $index}}, {{end}}{{$column.Name}}{{end}}`, vs...)\n\t{{- else}}\n    res, err := db.Exec(`INSERT INTO {{.Name}}(` + strings.Join(cs, \", \") + `) VALUES (` + strings.Join(ps, \", \") + `)`, vs...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tid, err := res.LastInsertId()\n\tif err != nil {\n\t\treturn err\n\t}\n\trow := db.QueryRow(`SELECT {{range $index, $column := .Columns}}{{if $index}}, {{end}}{{$column.Name}}{{end}} FROM {{.Name}} WHERE rowid = ?`, id)\n\t{{- end}}\n\treturn row.Scan({{range $index, $column := .Columns}}{{if $index}}, {{end}}&m.{{.Name | Camel}}{{end}})\n}\n\nfunc (m *{{.Name | singular | Camel}}) Update(db DB) error {\n\t{{- if eq $driver \"postgres\"}}\n    row := db.QueryRow(`UPDATE {{.Name}} SET {{range $index, $column := .Columns}}{{if $index}}, {{end}}{{$column.Name}} = ?{{end}} WHERE {{range $index, $column := .PrimaryKey}}{{if $index}}, {{end}}{{$column.Name}} = ?{{end}} RETURNING {{range $index, $column := .Columns}}{{if $index}}, {{end}}{{$column.Name}}{{end}}`{{range .Columns}}, m.{{.Name | Camel}}{{end}}{{range .PrimaryKey}}, m.{{.Name | Camel}}{{end}})\n    return row.Scan({{range $index, $column := .Columns}}{{if $index}}, {{end}}&m.{{.Name | Camel}}{{end}})\n\t{{- else}}\n    _, err := db.Exec(`UPDATE {{.Name}} SET {{range $index, $column := .Columns}}{{if $index}}, {{end}}\t{{$column.Name}} = ?{{end}} WHERE {{range $index, $column := .PrimaryKey}}{{if $index}}, {{end}}{{$column.Name}} = ?{{end}}`{{range .Columns}}, m.{{.Name | Camel}}{{end}}{{range .PrimaryKey}}, m.{{.Name | Camel}}{{end}})\n    return err\n\t{{- end}}\n}\n\nfunc (m *{{.Name | singular | Camel}}) Delete(db DB) error {\n\t_, err := db.Exec(`DELETE FROM {{.Name}} WHERE {{range $index, $column := .PrimaryKey}}{{if $index}} AND {{end}}{{$column.Name}} = ?{{end}}`{{range .PrimaryKey}}, m.{{.Name | Camel}}{{end}})\n\treturn err\n}\n\nfunc (m *{{.Name | singular | Camel}}) Find(db DB, scopes ...Scope) (bool, error) {\n\tq := Query{\n\t\tLimit: 1,\n\t}\n\tfor _, s := range scopes {\n\t\ts(&q)\n\t}\n\trow := db.QueryRow(`SELECT {{range $index, $column := .Columns}}{{if $index}}, {{end}}{{$column.Name}}{{end}} FROM {{.Name}}` + q.String(), q.Params()...)\n\tswitch err := row.Scan({{range $index, $column := .Columns}}{{if $index}}, {{end}}&m.{{.Name | Camel}}{{end}}); err {\n\tcase nil:\n\t\treturn true, nil\n\tcase sql.ErrNoRows:\n\t\treturn false, nil\n\tdefault:\n\t\treturn false, err\n\t}\n}\n\ntype {{.Name | plural | Camel}} []{{.Name | singular | Camel}}\n\nfunc (ms *{{.Name | plural | Camel}}) Find(db DB, scopes ...Scope) (bool, error) {\n\tvar q Query\n\tfor _, s := range scopes {\n\t\ts(&q)\n\t}\n\t*ms = (*ms)[:0]\n\trows, err := db.Query(`SELECT {{range $index, $column := .Columns}}{{if $index}}, {{end}}{{$column.Name}}{{end}} FROM {{.Name}}` + q.String(), q.Params()...)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer rows.Close()\n\tvar m {{.Name | singular | Camel}}\n\tfor rows.Next() {\n\t\tif err := rows.Scan({{range $index, $column := .Columns}}{{if $index}}, {{end}}&m.{{.Name | Camel}}{{end}}); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\t*ms = append(*ms, m)\n\t}\n\treturn len(*ms) != 0, nil\n}\n{{- end}}\n\ntype Scope func(*Query)\n{{- range .Columns}}\nfunc {{.Name | Camel}}(v interface{}) Scope {\n\treturn func(q *Query) {\n\t\tq.Where = append(q.Where, Condition{SQL: `{{.Name}} = ?`, Values: []interface{}{v}})\n\t}\n}\n\nfunc OrderBy{{.Name | Camel}}Asc(q *Query) {\n\tq.Order = append(q.Order, `{{.Name}} ASC`)\n}\n\nfunc OrderBy{{.Name | Camel}}Desc(q *Query) {\n\tq.Order = append(q.Order, `{{.Name}} DESC`)\n}\n{{- end}}\nfunc Limit(n int) Scope {\n\treturn func(q *Query) {\n\t\tq.Limit = n\n\t}\n}\n\ntype Query struct {\n\tWhere []Condition\n\tOrder []string\n\tLimit interface{}\n}\n\nfunc (q *Query) String() string {\n\tws := make([]string, 0, len(q.Where))\n\tfor _, c := range q.Where {\n\t\tws = append(ws, c.SQL)\n\t}\n\tps := make([]string, 0, 4)\n\tif q.Where != nil {\n\t\tps = append(ps, \" WHERE \")\n\t}\n\tps = append(ps, strings.Join(ws, \" AND \"))\n\tif q.Order != nil {\n\t\tps = append(ps, \" ORDER BY \", strings.Join(q.Order, \", \"))\n\t}\n\tif q.Limit != nil {\n\t\tps = append(ps, \" LIMIT ?\")\n\t}\n\treturn strings.Join(ps, \"\")\n}\n\nfunc (q *Query) Params() []interface{} {\n\tps := make([]interface{}, 0, len(q.Where)*2)\n\tfor _, c := range q.Where {\n\t\tps = append(ps, c.Values...)\n\t}\n\tif q.Limit != nil {\n\t\tps = append(ps, q.Limit)\n\t}\n\treturn ps\n}\n\ntype Condition struct {\n\tSQL string\n\tValues []interface{}\n}\n\ntype DB interface {\n\tExec(query string, args ...interface{}) (sql.Result, error)\n\tQuery(query string, args ...interface{}) (*sql.Rows, error)\n\tQueryRow(query string, args ...interface{}) *sql.Row\n}\n\n{{- if eq $driver \"postgres\"}}\n// BindVarDB replaces placeholders ? to postgres' $x\ntype BindVarDB struct {\n\tDB\n}\n\nvar placeholder = regexp.MustCompile(`\\?`)\n\nfunc bindVar(s string) string {\n\tvar i int\n\treturn placeholder.ReplaceAllStringFunc(s, func(s string) string {\n\t\ti++\n\t\treturn fmt.Sprintf(\"$%d\", i)\n\t})\n}\n\nfunc (db BindVarDB) Exec(query string, args ...interface{}) (sql.Result, error) {\n\treturn db.DB.Exec(bindVar(query), args...)\n}\n\nfunc (db BindVarDB) Query(query string, args ...interface{}) (*sql.Rows, error) {\n\treturn db.DB.Query(bindVar(query), args...)\n}\n\nfunc (db BindVarDB) QueryRow(query string, args ...interface{}) *sql.Row {\n\treturn db.DB.QueryRow(bindVar(query), args...)\n}\n{{- end}}\n\ntype FieldName string\n"

// Assets returns go-assets FileSystem
var Assets = assets.NewFileSystem(map[string][]string{"/": []string{"rel.tmpl"}}, map[string]*assets.File{
	"/": &assets.File{
		Path:     "/",
		FileMode: 0x800001ed,
		Mtime:    time.Unix(1514464769, 1514464769489911748),
		Data:     nil,
	}, "/rel.tmpl": &assets.File{
		Path:     "/rel.tmpl",
		FileMode: 0x1a4,
		Mtime:    time.Unix(1514464769, 1514464769488855872),
		Data:     []byte(_Assets46cddf908f5020eaa9e87763aca46435532701b4),
	}}, "")
